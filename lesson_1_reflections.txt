Commands learned:

	- FC (File Compare, in Windows Command Shell):  FC java.old java.new
	- diff -u (in GitBash): diff -u file.old file.new:  Compares file old with file new and shows changes

	- git log
	- git diff (commit id1) (commit id2)
	- git --version: determine your current git version 
	- git clone (URL of repository): copies a repository into the pwd
	- git checkout (commit id): 'checks out' the program as is based on the commit id entered

	Lesson 2:

	- ls -a: shows all files in a folder, including hidden files (starting with a '.')
	- git init: initializes/creates new (empty) git repository in the pwd
	- git status: shows which files have changed since the last commit (if run right after git init, all files will shown as changed)
	- git add: adds files to the staging area before the actual commit

	Choosing what changes to commit (example):

	******************				 ******************				******************	
	* PWD            *				 * Staging        *				* Repository     *
	*                *	add to 		 * Area           *				*                *
	*				 *	staging area *                *	 Commit		*                *
	*	cake.txt	 *	------->	 *	 cake.txt     *	 ------->	*	cake.txt	 *
	*	frosting.txt *	------->	 *	 frosting.txt *	 			*	frosting.txt *
	*	chili.txt	 *				 *	              *				*				 *
	*				 *				 *                *				*                *
	*				 *				 *                *				*                *
	******************				 ******************				******************






Definitions:

	- Commit: Snapshot of every file of your repository at the time you choose to make the commit
	- Repository: Multiple files that are tracked together and run together for the program to function properly
	- HEAD: Current commit






How did viewing a diff between two versions of a file help you see the bug that was introduced?

	Viewing the diff helped me because it showed a succinct version of the differences between
the two files. That means that instead of combing through lines of code, potentially
thousands of them, the program sends an output that becomes much more manageable. 
Another advantage of the FC/diff program is that the output can be organized using 
attributes. 


How could having easy access to the entire history of a file make you a more efficient programmer in the long term?

	The ability to access the entire history of a file will minimize room for human error.	


What do you think are the pros and cons of manually choosing when to create a commit, like you do in Git, 
vs having versions automatically saved, like Google docs does?

	The pros: more power and control over when to save. This potentially results in the ideal number of 
commits and neither over- nor underpopulates the number of versions saved.
The cons: Manually saving is prone to human error or laziness, thus it can happen that
a) either one forgets to save at an appropriate time and thus work, effort, time, and
money is lost or b) versions aren't documented well enough.


Why do you think some version control systems, like Git, allow saving multiple files in one commit,
while others, like Google Docs, treat each file separately?

	Saving multiple files in one commit helps keeping files in order: instead of having to dig through
a large number of interrelated files separately, the system outputs all changes that affected
the file repository. This is particularly useful if writing in code, since a lot of files depend
on other files here. Google Docs does not use this system because Google Docs is not built
with the thought in mind that files would be interdependend.


How can you use the commands git log and git diff to view the history of files?

	The 'git log' command lets me see all the different commits that have been made for 
a single repository. It lists them in chronological order. Once I know which two 
versions or commits I would like to compare, I can use the 'git diff' command
in connection with the commit IDs to see which lines have been added and which
have been removed (use ID of earlier or first version first)


How might using version control make you more confident to make changes that could break something?

	It makes it easier to revert to a previous version if need be.


Now that you have your workspace set up, what do you want to try using Git for?

	I want to understand how to use it to store my versions of code on Github




Git commands learned:
	Lesson 1:
		diff (commit1 commit2)
		git log
		git clone
		git checkout
		 

	